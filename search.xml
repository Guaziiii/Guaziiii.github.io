<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/10/23/vr02qz/"/>
      <url>/2022/10/23/vr02qz/</url>
      
        <content type="html"><![CDATA[<h3 id="活在我，飞扬的青春。泪水中的晨昏常让我往远方出神。"><a href="#活在我，飞扬的青春。泪水中的晨昏常让我往远方出神。" class="headerlink" title="活在我，飞扬的青春。泪水中的晨昏常让我往远方出神。"></a>活在我，飞扬的青春。泪水中的晨昏常让我往远方出神。</h3><p>灰啊发官方<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/32571334/1666530304632-efdff8f1-cb81-471f-a0b3-52f2ed706c3e.jpeg#clientId=u6f984e49-ab97-4&crop=0&crop=0&crop=1&crop=1&errorMessage=unknown%20error&from=ui&id=ub36af2a3&margin=%5Bobject%20Object%5D&name=1.jpg&originHeight=1080&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=98639&status=error&style=none&taskId=u46bca4c8-851c-451f-87a4-50456fffc86&title=" alt="1.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/23/qv0i5i/"/>
      <url>/2022/10/23/qv0i5i/</url>
      
        <content type="html"><![CDATA[<p>那是你离开了深圳的生活</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/23/eduuz2/"/>
      <url>/2022/10/23/eduuz2/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-Springdate-2022-08-20-21-50-05"><a href="#title-Springdate-2022-08-20-21-50-05" class="headerlink" title="title: Springdate: 2022-08-20 21:50:05"></a>title: Springdate: 2022-08-20 21:50:05</h2><p>tags: Spring,java</p><p>categories: study</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/23/gzqzs8/"/>
      <url>/2022/10/23/gzqzs8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-流程"><a href="#1-流程" class="headerlink" title="1.流程"></a>1.流程</h2><ul><li><p>业务人员进行评估，需求分析</p></li><li><p>分库</p><ul><li>不同模块分库</li></ul></li><li><p>分表</p><ul><li>模块的不同功能分表</li></ul></li><li><p>增加冗余字段</p><ul><li>增加特殊功能</li></ul></li></ul><h2 id="2-项目的数据库的设计"><a href="#2-项目的数据库的设计" class="headerlink" title="2.项目的数据库的设计"></a>2.项目的数据库的设计</h2><p>模块分库功能分表，就拿我负责的商品详情来说的话主要是两个大类，供后台管理和前台显示的信息。</p><p>后台管理就是商品的上下架，商品的个数等。前台显示的信息的话比如商品的详细信息，根据属性来分类，销售属性和平台属性来分类。销售属性不参与检索，平台属性有一些参与检索。比如说外卖餐盒的一级分类是公司，二级分类是外卖餐盒的制作标准，国标多少。三级分类就是外卖餐盒的尺寸。这是用于分类的，其中都是一对多的关系。平台属性中有三级分类的 id 字段。实现一个三级分类检索的作用。</p><blockquote><p>答：一般来说做一个项目的数据库表的设计有以下几个步骤。首先需要业务人员了解需求，收集相关的数据。开发人员根据需求的模块分库，拿具体功能分表，可能是一个表一个功能，也可能是多个表数据做一个功能。</p></blockquote><blockquote><p>拿我之前的项目来说，商品详情分一个库，存储的是商品的详情。由于需要检索和商品详细信息的展示功能，商品有三级分类，一级分类对应多个二级分类，二级分类对应多个三级分类。根据属性又分为销售属性和平台属性，销售属性不参与检索，平台属性参与检索。</p></blockquote><h2 id="3-分布式事务的解决方案"><a href="#3-分布式事务的解决方案" class="headerlink" title="3.分布式事务的解决方案?"></a>3.分布式事务的解决方案?</h2><p>主要是看业务场景，比如说要求强一致性的场景，比如说下单之后减库存，生成订单可以使用 seata 的 at 模式</p><p>弱一致性的场景，比如订单支付成功，修改订单状态等使用 seata 的 ttc 模式。</p><p>最终一致性的场景，比如说支付成功通知结果，支付成功之后需要根据仓库拆单之类的使用消息队列保证事务最终一致性。</p><h2 id="4-单点登录"><a href="#4-单点登录" class="headerlink" title="4.单点登录"></a>4.单点登录</h2><p>用户登录之后会生成一个唯一令牌，存到 redis 中，并存储用户相关信息。返回给前端要求每次访问的时候带上唯一令牌，普通请求 cookie 请求头中，ajax 是在 cookie 请求头的 token 字段中。请求的时候拿唯一标识就行。之后微服务需要使用的话就把老请求中的字段写给新请求，再讲一讲 openfeign 的原理。</p><h2 id="5-mybatisplus-解决-5-个字段修改两个字段的问题"><a href="#5-mybatisplus-解决-5-个字段修改两个字段的问题" class="headerlink" title="5.mybatisplus 解决 5 个字段修改两个字段的问题"></a>5.mybatisplus 解决 5 个字段修改两个字段的问题</h2><h2 id="6-redis-的商品详情的-key-如何设计"><a href="#6-redis-的商品详情的-key-如何设计" class="headerlink" title="6.redis 的商品详情的 key 如何设计"></a>6.redis 的商品详情的 key 如何设计</h2><p>redis 毕竟是缓存，查的数据肯定是从 mysql 中来。mysql 中商品详情有销售属性和平台属性，根据表名来和 id 来设计 redis 的 key。redis 只负责查的数据，查询就行。根据不同模块来选，购物车用 hash，商品详情用 string</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/23/nhlgug/"/>
      <url>/2022/10/23/nhlgug/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-测试-date-2022-08-20-01-08-21"><a href="#title-测试-date-2022-08-20-01-08-21" class="headerlink" title="title: 测试 date: 2022-08-20 01:08:21"></a>title: 测试 date: 2022-08-20 01:08:21</h2><p>tags: “study”</p><p>categories: “study”</p><h1 id="你在干什么？"><a href="#你在干什么？" class="headerlink" title="你在干什么？"></a>你在干什么？</h1><h2 id="你到底在干什么？"><a href="#你到底在干什么？" class="headerlink" title="你到底在干什么？"></a>你到底在干什么？</h2><ul><li><p>我不到啊</p></li><li><p>我不到啊</p></li><li><p>我不到 a</p></li><li><p><input disabled="" type="checkbox"> 受你妈呢</p></li><li><p><input disabled="" type="checkbox"> 说昂发</p></li><li><p><input disabled="" type="checkbox"> 撒旦法</p></li></ul><ol><li>阿打算放</li></ol><p>士大夫阿斯蒂芬</p><p>士大夫撒旦法 asd</p><p>是打发斯地方</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/23/tnz3bk/"/>
      <url>/2022/10/23/tnz3bk/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-学习-date-2022-08-20-20-10-21"><a href="#title-学习-date-2022-08-20-20-10-21" class="headerlink" title="title: 学习 date: 2022-08-20 20:10:21"></a>title: 学习 date: 2022-08-20 20:10:21</h2><p>tags: study</p><p>Categories: study</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/23/mx0ko0/"/>
      <url>/2022/10/23/mx0ko0/</url>
      
        <content type="html"><![CDATA[<h1 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h1><h2 id="1-讲一下-Hashmap-在-jdk1-7-多线程开发环境下的死循环问题"><a href="#1-讲一下-Hashmap-在-jdk1-7-多线程开发环境下的死循环问题" class="headerlink" title="1.讲一下 Hashmap 在 jdk1.7 多线程开发环境下的死循环问题"></a>1.讲一下 Hashmap 在 jdk1.7 多线程开发环境下的死循环问题</h2><p>答：由于 Hashmap 在 jdk1.7 下的数据结构是由 数组 + 链表 组成的，而当 Hashmap 需要扩容时，会调用一个 transfer 方法创建新表并且将旧表的数据赋值过去。但是由于赋值数据是头插法，第一个线程存入新表后数据顺序改变，第二个线程恢复对新表进行扩容时会导致 next 指向错误导致成环，最终导致 cpu 占用过高的问题。</p><h2 id="2-hashmap-和-concurrenHashmap-的区别"><a href="#2-hashmap-和-concurrenHashmap-的区别" class="headerlink" title="2.hashmap 和 concurrenHashmap 的区别"></a>2.hashmap 和 concurrenHashmap 的区别</h2><p>答：1.7 之前 hashmap 的数据结构是 数组 + 链表，且在扩容的时候采用头插法。此时在多线程的环境下会导致死锁，线程不安全。而 1.8 之后采用数组 + 链表 + 红黑树的数据结构，扩容的时候采用尾插法，多线程环境下不会死锁，但会造成数据丢失问题。而 concurrentHashmap 在 jdk1.7 中是由一个 segment 数组和多个 HashEntry 组合，concurrentHashmap 在多线程环境下由于加了读写锁且只锁当前的 segment 数组，其他 segment 可以正常读写，所以是线程安全的。在 jdk1.8 中抛弃了 segment ，改用 node 数组+链表+红黑树的结构。</p><h2 id="3-Hashmap-在-jdk1-8-是如何实现的？"><a href="#3-Hashmap-在-jdk1-8-是如何实现的？" class="headerlink" title="3.Hashmap 在 jdk1.8 是如何实现的？"></a>3.Hashmap 在 jdk1.8 是如何实现的？</h2><p>答：Hashamp 在 1.8 之后采用数组，链表，红黑树的数据结构。hashmap 有一个动态扩容的机制，当链表长度超过 8 或者装载因子超过 0.75 时，会将容量扩容为原来的两倍。为什么长度超过 8 才扩容是因为红黑树在数据量小的时候需要通过改变节点颜色和旋转来保持平衡，综合来说性能不如用数组+链表</p><h2 id="4-多线程如何保证安全"><a href="#4-多线程如何保证安全" class="headerlink" title="4.多线程如何保证安全"></a>4.多线程如何保证安全</h2><p>答：Synchronized 和 lock 上锁，Synchronized 通过反编译可以看到是通过一个 monitorenter 开始，到 monitorexit 期间操作是同步的，而 lock 相比 Synchronized 更加面向对象。</p><h2 id="5-讲一讲-Synchronized-和-lock-不同情况的锁对象"><a href="#5-讲一讲-Synchronized-和-lock-不同情况的锁对象" class="headerlink" title="5.讲一讲 Synchronized 和 lock 不同情况的锁对象"></a>5.讲一讲 Synchronized 和 lock 不同情况的锁对象</h2><p>答：Synchronized 标注在普通方法上时，锁对象是 this，而标注在静态方法上时，锁对象的 xxx.class，标注同步代码块时，默认的锁对象是自定义的。而 lock 锁分为可重入锁和读写锁，可重入锁在不同的线程中可以通过 condition 的 await()方法和 signal()方法实现线程通信的多路通知，读写锁的特点是在多线程的环境下，读读共享，读写互斥，写写也是互斥的。lock 锁的对象是谁调用 lock 谁就是锁对象</p><h2 id="6-Hash1-7-是基于数组和链表实现的，为什么不用双链表？HashMap1-8-中引入红黑树的原因是？为什么要用红黑树而不是平衡二叉树？"><a href="#6-Hash1-7-是基于数组和链表实现的，为什么不用双链表？HashMap1-8-中引入红黑树的原因是？为什么要用红黑树而不是平衡二叉树？" class="headerlink" title="6.Hash1.7 是基于数组和链表实现的，为什么不用双链表？HashMap1.8 中引入红黑树的原因是？为什么要用红黑树而不是平衡二叉树？"></a>6.Hash1.7 是基于数组和链表实现的，为什么不用双链表？HashMap1.8 中引入红黑树的原因是？为什么要用红黑树而不是平衡二叉树？</h2><p>答：使用链表的原因是为了解决 hash 冲突的问题，单链表就可以完成，使用双链表的话消耗性能更大，引入红黑树的原因是在 jdk1.7 中，hashmap 中的链表数据过大时，由于链表的数据结构的特点，查询消耗的性能过大，则采用红黑树去满足查询的功能。红黑树是自平衡数，相较于平衡二叉树在修改和删除时由于保持平衡而发生的旋转损耗性能更低，所以采用红黑树。</p><h2 id="7-HashMap、HashTable、ConcurrentHashMap-的原理与区别？"><a href="#7-HashMap、HashTable、ConcurrentHashMap-的原理与区别？" class="headerlink" title="7.HashMap、HashTable、ConcurrentHashMap 的原理与区别？"></a>7.HashMap、HashTable、ConcurrentHashMap 的原理与区别？</h2><p>答：hashtable：由数组+链表组成，无论是 key 还是 value 都不能为 null，线程安全的原因是进行修改时通过 Synchronized 锁住整个 Hashtable，导致性能低下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hashmap：插入链表之后才产生扩容，有可能产生无效扩容，线程不安全，key和value可以为null，扩容时会将map中的每个值都transfer到新的链表中。</span><br><span class="line"></span><br><span class="line">concurrentHashmap：底层采用分段的segment数组 + 链表实现，线程安全的原因是采用了锁分离技术，也就是多线程的情况下只锁住一段bucket，其他的桶可以正常进行操作修改。</span><br></pre></td></tr></table></figure><h2 id="8-volatile-与-synchronized-的区别是什么？volatile-作用（必考）"><a href="#8-volatile-与-synchronized-的区别是什么？volatile-作用（必考）" class="headerlink" title="8.volatile 与 synchronized 的区别是什么？volatile 作用（必考）"></a>8.volatile 与 synchronized 的区别是什么？volatile 作用（必考）</h2><p>答：在多线程的环境下，有三个特性，分别是原子性，可见性，有序性。volatile 可以保证在工作内存中修改的值第一时间被其他工作内存感知到，且可以保证在变量进行创建和赋值的时候保证操作的有序性，防止先给内存地址后创建对象。区别则是 volatile 只能作用在变量上，而 synchronized 可以作用在变量，方法，类上。synchronized 可能造成线程阻塞，volatile 不能保证原子性</p><h2 id="9-Atomic-类如何保证原子性（CAS-操作）（必考）"><a href="#9-Atomic-类如何保证原子性（CAS-操作）（必考）" class="headerlink" title="9.Atomic 类如何保证原子性（CAS 操作）（必考）"></a>9.Atomic 类如何保证原子性（CAS 操作）（必考）</h2><p>答：使用 volatile 关键字来保证内存的可见性，线程的读操作去主内存中读，线程在工作内存的写操作完成后立刻刷新到主内存中。但 Atomic 的原子性需要通过 CAS 自旋来保证，也就是当线程进行写操作时，保存一份旧版本数据，多线程的环境下先比较当前数据和旧版本数据是否匹配，若匹配则进行写操作。</p><h2 id="10-Java-不可重入锁与可重入锁的区别如何理解？"><a href="#10-Java-不可重入锁与可重入锁的区别如何理解？" class="headerlink" title="10.Java 不可重入锁与可重入锁的区别如何理解？"></a>10.Java 不可重入锁与可重入锁的区别如何理解？</h2><p>答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可重入锁表示一个类中的两个方法，两个方法拿到同一把锁。多线程的条件下可以是相同的线程拿到锁，也可以是不同的线程拿到锁。线程通信就是通过可重入锁的通知队列的await()方法和singal()来实现的。看源码可以知道可重入锁不仅记录了锁的数量，也记录了是谁拿到了锁，其中会判断该对象是否被锁了，是不是被此线程加锁，若是则必须等待，若不是则锁的数量加一。这样设计的好处是当锁的数量为0的时候，判断可以解锁，提供一个解锁的标准。</span><br><span class="line"></span><br><span class="line">而不可重入锁则是类似读写锁，读的操作和写的操作不可以同时进行，所以不可重入锁是不能同时被两个线程拿到，会出现死锁的问题。</span><br></pre></td></tr></table></figure><h2 id="11-多线程中-sleep-与-wait-的区别是什么？"><a href="#11-多线程中-sleep-与-wait-的区别是什么？" class="headerlink" title="11.多线程中 sleep 与 wait 的区别是什么？"></a>11.多线程中 sleep 与 wait 的区别是什么？</h2><p>答：sleep 和 wait 都是让线程进入休眠状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">不同点：1.sleep需要传参，且进入休眠之后不会释放锁资源。而wait进入休眠之后会释放锁资源</span><br><span class="line"></span><br><span class="line">  2.wait其实是使用了synchronized关键字，而sleep不用</span><br><span class="line"></span><br><span class="line">  3.wait属于Object的方法，而sleep是Thread的方法</span><br></pre></td></tr></table></figure><h2 id="12-线程的状态有哪些"><a href="#12-线程的状态有哪些" class="headerlink" title="12.线程的状态有哪些"></a>12.线程的状态有哪些</h2><p>![image-20220623171610155](&#x2F;Users&#x2F;guazi&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220623171610155.png)</p><h2 id="13-final、finnally、finalize-的区别是什么？"><a href="#13-final、finnally、finalize-的区别是什么？" class="headerlink" title="13.final、finnally、finalize 的区别是什么？"></a>13.final、finnally、finalize 的区别是什么？</h2><p>答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final是关键字，被final修饰的变量无法被修改，修饰的类无法被继承，修饰的方法无法被重写。且在类加载器的编译阶段就分配了内存空间。</span><br><span class="line"></span><br><span class="line">finally是在java进行异常处理时最后阶段一定会执行的操作</span><br><span class="line"></span><br><span class="line">finalize则是Object类的一个方法，在GC进行垃圾回收之前需要调用的方法</span><br></pre></td></tr></table></figure><h2 id="14-谈一谈你对-HashMap-的理解"><a href="#14-谈一谈你对-HashMap-的理解" class="headerlink" title="14.谈一谈你对 HashMap 的理解"></a>14.谈一谈你对 HashMap 的理解</h2><p>Hashmap 是对 map 接口的一个具体实现，它的底层数据结构在 1.7 及之前是使用数组+链表，并且在多线程的环境下有一个死锁的问题，由于链表扩容的时候采用的是头插法，所以当地一个线程创建新数组使用 transfer 方法进行数据转移完成后，第二个线程进入开始扩容时，链表的第一个节点的 next 指向下一个节点，而下一个节点的 next 指向第一个节点，这样就形成了死锁。也有人提过 issue，但是公司说这不是一个 bug，多线程的环境下 hashmap 就是不安全的，建议使用 hashtable 和 concurrenthashmap，但到了 jdk1.8 的时候，由于红黑树的出现，hashmap 的结构改成了数组+链表+红黑树，这样极端情况的时间复杂度也能保证在 O(log2n),它的扩容条件是需要链表长度大于 8 或者数组长度大于 64 会转化为红黑树。链表+红黑树主要是为了防止 hash 碰撞产生超长的链表，避免查询时需要遍历这个超长的链表导致性能下降。</p><h2 id="15-HashMap-的-put-的流程"><a href="#15-HashMap-的-put-的流程" class="headerlink" title="15. HashMap 的 put 的流程"></a>15. HashMap 的 put 的流程</h2><p>首先判断 hash 表是否为空，需不需要初始化。再判断有没有 hash 冲突，不冲突就直接插入值，如果产生 hash 冲突就要判断插入元素是否相等，如果相等则替换，如果不相等判断结构，如果结构是红黑树直接插入，如果是链表则遍历链表看是否有相同的元素，并采用尾插法，插完需要判断是否需要把链表转换为红黑树。</p><h2 id="16-了解-ConcurrentHashMap-吗-为什么性能比-hashtable-高，说下原理"><a href="#16-了解-ConcurrentHashMap-吗-为什么性能比-hashtable-高，说下原理" class="headerlink" title="16.了解 ConcurrentHashMap 吗?为什么性能比 hashtable 高，说下原理"></a>16.了解 ConcurrentHashMap 吗?为什么性能比 hashtable 高，说下原理</h2><p>由于锁的粒度越小，则并发吞吐量更高，而 ConcurrentHashMap 在高并发的环境下使用 segment 继承了重入锁将数据分成一段段存储，每个数据段配置一把锁。而 JDK1.8 之后使用了 node 数组+链表+红黑树的结构，实现了对每一段数据行加锁，减少了并发冲突的概率，而比 hashtable 效率高的原因是因为 hashtable 采用 synchronized 锁，高并发情况下效率非常的低</p><h2 id="18-ArrayList-和-LinkedList-的区别"><a href="#18-ArrayList-和-LinkedList-的区别" class="headerlink" title="18.ArrayList 和 LinkedList 的区别"></a>18.ArrayList 和 LinkedList 的区别</h2><p>答：首先 arraylist 是基于动态数组的数据结构，而 LinkedList 是基于双向链表的数据结构。数据结构的不同导致在不同的操作中有不同的优势。对于随机访问 get 和 set，arraylist 性能优于 linkedlist，因为 arraylist 是有索引的，并且 linkedlist 在操作过程中是需要移动指针的，而对于批量的随机插入删除数据，linkedlist 是优于 arraylist 的，因为 arraylist 每插入一条数据都需要移动插入点之后的所有数据</p><h2 id="19-StringBuffer-和-StringBuilder-的区别"><a href="#19-StringBuffer-和-StringBuilder-的区别" class="headerlink" title="19.StringBuffer 和 StringBuilder 的区别"></a>19.StringBuffer 和 StringBuilder 的区别</h2><p>答 stringbuffer 和 stringbuilder 的方法和功能完全相同，但是 stringbuffer 的方法中采用了同步锁 sychronized 关键字修饰，所以是线程安全的，但是 stringbuilder 没有此修饰，线程不安全。涉及到效率方面，stringbuffer 由于需要 synchornized 需要让阻塞的线程进入阻塞队列，抢到资源后进入 runable 状态。过程设计到系统用户和设计模式的转换，更加消耗资源</p><h2 id="20-线程的创建方式"><a href="#20-线程的创建方式" class="headerlink" title="20. 线程的创建方式"></a>20. 线程的创建方式</h2><p>答：线程的创建方式有四种，第一种是：继承 thread 类创建对象，缺点是 java 不能多继承。第二种实现 runable 来创建对象，看源码可知知道，在 thread 中传入一个 Runable 类型的 target，当用 run 方法前，会判断 target 是否为 null，由此来实现第二种创建线程的方法，第三种是使用 callable 和 futur</p><h2 id="21-基本类型和包装类型的区别"><a href="#21-基本类型和包装类型的区别" class="headerlink" title="21.基本类型和包装类型的区别"></a>21.基本类型和包装类型的区别</h2><ul><li>成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li><li>包装类型可用于泛型，而基本类型不可以。</li><li>基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li><li>相比于对象类型， 基本数据类型占用的空间非常小。</li></ul><p><strong>为什么说是几乎所有对象实例呢？</strong> 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p><p>⚠️ 注意 ： <strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的成员变量如果没有被 <code>static</code> 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。</p><h2 id="22-包装类型的缓存机制"><a href="#22-包装类型的缓存机制" class="headerlink" title="22.包装类型的缓存机制"></a>22.包装类型的缓存机制</h2><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p><h2 id="23-自动装箱和拆箱的原理了解嘛？"><a href="#23-自动装箱和拆箱的原理了解嘛？" class="headerlink" title="23.自动装箱和拆箱的原理了解嘛？"></a>23.自动装箱和拆箱的原理了解嘛？</h2><p>自动装箱：基本数据类型用引用数据类型包装起来；</p><p>自动拆箱：将包装类型转换为基本数据类型；</p><h2 id="24-接口和抽象类的区别"><a href="#24-接口和抽象类的区别" class="headerlink" title="24.接口和抽象类的区别"></a>24.接口和抽象类的区别</h2><p>相同点：都不可以被实例化、都可以包含抽象方法、都可以有默认的实现。</p><p>不同点：接口主要是对实现类的行为进行约束，而抽象类则更加强调从属关系、单继承，多实现、接口的成员变量被<code>public static final</code>修饰，所以不能修改且必须有初始值，而抽象类的成员变量可以在子类中重新定义和赋值。</p><h2 id="25-浅拷贝，深拷贝，引用拷贝了解吗？"><a href="#25-浅拷贝，深拷贝，引用拷贝了解吗？" class="headerlink" title="25.浅拷贝，深拷贝，引用拷贝了解吗？"></a>25.浅拷贝，深拷贝，引用拷贝了解吗？</h2><p>引用拷贝是不同引用指向同一对象，深拷贝则是不同引用指向不同对象，浅拷贝则是不同引用指向不同对象的成员属性。</p><h2 id="26-equal-和-x3D-x3D-的区别？"><a href="#26-equal-和-x3D-x3D-的区别？" class="headerlink" title="26.equal 和&#x3D;&#x3D;的区别？"></a>26.equal 和&#x3D;&#x3D;的区别？</h2><p>&#x3D;&#x3D;：基本属性类型比值。引用数据类型比地址。</p><p>equal：不重写则是引用 Object 类下的 equal 跟<code>==</code>一样,若重写则一般比较属性值。</p><h2 id="27-为什么重写-equal-同时必须重写-hashcode-方法？"><a href="#27-为什么重写-equal-同时必须重写-hashcode-方法？" class="headerlink" title="27.为什么重写 equal()同时必须重写 hashcode()方法？"></a>27.为什么重写 equal()同时必须重写 hashcode()方法？</h2><p>因为无论是 equal()还是 hashcode()方法，最终目的都是比较两个对象是否相同。而 equal 只能保证对象相等，hash 值不相等。而只有 hashcode()的话可能会产生 hash 碰撞的问题。</p><h2 id="28-String、StringBuffer、StringBuilder-的区别？"><a href="#28-String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="28.String、StringBuffer、StringBuilder 的区别？"></a>28.String、StringBuffer、StringBuilder 的区别？</h2><p>可变性：String 是不可变的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   StringBuffer和StringBuilder都是继承自AbstractStringBuilder类，类中包含了许多操作字符串的方法。</span><br></pre></td></tr></table></figure><p>线程安全性：</p><ul><li>String 是线程安全的</li><li>StringBuffer 加了同步锁，是线程安全的。</li><li>StringBuilder 没有加同步锁，线程不安全。</li></ul><p>性能：</p><ul><li>String 每次操作都会创建新的对象</li><li>StringBuilder 比 StringBuffer 性能高 10%-15%，但是需要冒着线程不安全的风险。</li></ul><h2 id="29-和-StringBuilder-用于字符串拼接的区别？"><a href="#29-和-StringBuilder-用于字符串拼接的区别？" class="headerlink" title="29.+和 StringBuilder 用于字符串拼接的区别？"></a>29.+和 StringBuilder 用于字符串拼接的区别？</h2><p><code>+</code>：其实也是调用 StringBuilder 的 append()方法进行拼接，但是他不会复用 StringBuilder 对象。所以一般考虑 StringBuidler 来字符串拼接。并且拼接之前会进行常量折叠：对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code> 编译器会给你优化成 <code>String str3 = &quot;string&quot;;</code> 。</p><h2 id="30-String-s1-x3D-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#30-String-s1-x3D-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="30.String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？"></a>30.String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</h2><p>一个或两个，如果常量池没有“abc”则需要创建，若有则不需要创建。之后会把 String 对象引用指向常量池的”abc”.</p><h2 id="31-什么是泛型，泛型有几种使用方式？"><a href="#31-什么是泛型，泛型有几种使用方式？" class="headerlink" title="31.什么是泛型，泛型有几种使用方式？"></a>31.什么是泛型，泛型有几种使用方式？</h2><p>泛型就是编译器可以对泛型类型进行检查，可以指定传入的对象类型。比如 <code>ArrayList&lt;Persion&gt; persons = new ArrayList&lt;Persion&gt;()</code> 这行代码就指明了该 <code>ArrayList</code> 对象只能传入 <code>Persion</code> 对象，如果传入其他类型的对象就会报错。</p><p>三种使用方式：</p><ul><li>泛型类指定成员属性类型</li><li>泛型接口指定抽象方法的返回参数</li><li>泛型方法</li></ul><h2 id="32-什么是序列化-什么是反序列化？"><a href="#32-什么是序列化-什么是反序列化？" class="headerlink" title="32.什么是序列化?什么是反序列化？"></a>32.什么是序列化?什么是反序列化？</h2><p>当 java 对象需要持久化或者通过网络传输时，都需要先序列化成二进制的字节流。</p><h2 id="33-ArrayList-与-LinkedList-区别"><a href="#33-ArrayList-与-LinkedList-区别" class="headerlink" title="33.ArrayList 与 LinkedList 区别?"></a>33.ArrayList 与 LinkedList 区别?</h2><ul><li>都是线程不安全的</li><li>Arraylist 是 Object[]数组而 LinkedList 是使用的双向链表</li><li>ArrayList 数组存储，add 直接在末尾插入，时间复杂度是 O(1),指定位置插入和删除的话时间复杂度是 O(n-1)，因为之后的元素都需要移动位置。LinkedList 是链表存储，所以头尾插入时间复杂度是 O(1),如果指定位置插入或者删除的话时间复杂度是 O(n)。</li><li>ArrayList 支持快速访问元素，而 LinkedList 不支持。</li><li>总结，直接用 ArrayList 就完事儿了。</li></ul><h2 id="34-Arraylist-的扩容机制你了解多少？"><a href="#34-Arraylist-的扩容机制你了解多少？" class="headerlink" title="34.Arraylist 的扩容机制你了解多少？"></a>34.Arraylist 的扩容机制你了解多少？</h2><p>arraylist 继承与**<code>AbstractList</code>**,实现了 list，RandomAccess，Cloneable，Serializable 等接口，支持随机访问、克隆、序列化等。</p><p>调用无参构造初始化后默认容量为 10.grow(默认容量)方法中通过位右移并+默认容量来扩容，1.5 倍。判断扩容后的容量是否大于最小容量，若不大于则设最小容量为 arraylist 容量。如果超过 integer.max_value 则设置为 integer 最大值-8。System.arraycopy()复制数组指定位置指定长度的数据到新数组的指定位置。Arrays.copyof()主要是给数组扩容。其中的 ensureCapacity()在进行大量 add 操作时使用，可以减少增量重新分配的次数。他会增加 arraylist 实例的容量，防止多次进行 grow().</p><h2 id="35-MyISAM-和-InnoDB-的区别是什么？"><a href="#35-MyISAM-和-InnoDB-的区别是什么？" class="headerlink" title="35.MyISAM 和 InnoDB 的区别是什么？"></a>35.MyISAM 和 InnoDB 的区别是什么？</h2><ul><li>MyISAM 不支持行锁，而 InnoDB 支持行锁且支持表锁。</li><li>MyISAM 没有事务，但是 InnoDB 支持事务。</li><li>MyISAM 不支持外键，但是 InnoDB 支持外键。</li><li>MyISAM 不支持安全恢复，InnoDB 支持</li><li>索引实现不一样，虽然都是使用 B+Tree，MyISAM 中索引和数据是分离的，数据文件本身按照 B+Tree 组织的索引结构，叶节点的 data 中存储了所有的数据。</li></ul><h2 id="36-聚簇索引和非聚簇索引的优缺点？"><a href="#36-聚簇索引和非聚簇索引的优缺点？" class="headerlink" title="36.聚簇索引和非聚簇索引的优缺点？"></a>36.聚簇索引和非聚簇索引的优缺点？</h2><p>聚簇索引是 data 中同时存放数据和索引结构，非聚簇索引分开存放结构和索引。</p><p>聚簇索引查询速度非常快，但是依赖数据有序和数据的类型。并且更新代价很大。</p><p>非聚簇索引更新的代价很小，但是同样依赖有序的数据，也可能会二次查询(回表)</p><h2 id="37-Spring-中-FactoryBean-和-BeanFactory-的区别？"><a href="#37-Spring-中-FactoryBean-和-BeanFactory-的区别？" class="headerlink" title="37.Spring 中 FactoryBean 和 BeanFactory 的区别？"></a>37.Spring 中 FactoryBean 和 BeanFactory 的区别？</h2><p>也就是工厂 Bean 和 Bean 工厂的区别，Bean 工厂，顾名思义是根据类的属性去生成我们需要的各种各样的 Bean，也就是说 Bean 工厂其实是提供了一套规范来获取 Bean 实例，那么工厂 Bean 则是动态的生成某一类型的 Bean 实例，可以自定义一个 Bean 加载到 IOC 容器中。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/23/pekwdg/"/>
      <url>/2022/10/23/pekwdg/</url>
      
        <content type="html"><![CDATA[<h1 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h1><h2 id="1-讲一下-Hashmap-在-jdk1-7-多线程开发环境下的死循环问题"><a href="#1-讲一下-Hashmap-在-jdk1-7-多线程开发环境下的死循环问题" class="headerlink" title="1.讲一下 Hashmap 在 jdk1.7 多线程开发环境下的死循环问题"></a>1.讲一下 Hashmap 在 jdk1.7 多线程开发环境下的死循环问题</h2><p>答：由于 Hashmap 在 jdk1.7 下的数据结构是由 数组 + 链表 组成的，而当 Hashmap 需要扩容时，会调用一个 transfer 方法创建新表并且将旧表的数据赋值过去。但是由于赋值数据是头插法，第一个线程存入新表后数据顺序改变，第二个线程恢复对新表进行扩容时会导致 next 指向错误导致成环，最终导致 cpu 占用过高的问题。</p><h2 id="2-hashmap-和-concurrenHashmap-的区别"><a href="#2-hashmap-和-concurrenHashmap-的区别" class="headerlink" title="2.hashmap 和 concurrenHashmap 的区别"></a>2.hashmap 和 concurrenHashmap 的区别</h2><p>答：1.7 之前 hashmap 的数据结构是 数组 + 链表，且在扩容的时候采用头插法。此时在多线程的环境下会导致死锁，线程不安全。而 1.8 之后采用数组 + 链表 + 红黑树的数据结构，扩容的时候采用尾插法，多线程环境下不会死锁，但会造成数据丢失问题。而 concurrentHashmap 在 jdk1.7 中是由一个 segment 数组和多个 HashEntry 组合，concurrentHashmap 在多线程环境下由于加了读写锁且只锁当前的 segment 数组，其他 segment 可以正常读写，所以是线程安全的。在 jdk1.8 中抛弃了 segment ，改用 node 数组+链表+红黑树的结构。</p><h2 id="3-Hashmap-在-jdk1-8-是如何实现的？"><a href="#3-Hashmap-在-jdk1-8-是如何实现的？" class="headerlink" title="3.Hashmap 在 jdk1.8 是如何实现的？"></a>3.Hashmap 在 jdk1.8 是如何实现的？</h2><p>答：Hashamp 在 1.8 之后采用数组，链表，红黑树的数据结构。hashmap 有一个动态扩容的机制，当链表长度超过 8 或者装载因子超过 0.75 时，会将容量扩容为原来的两倍。为什么长度超过 8 才扩容是因为红黑树在数据量小的时候需要通过改变节点颜色和旋转来保持平衡，综合来说性能不如用数组+链表</p><h2 id="4-多线程如何保证安全"><a href="#4-多线程如何保证安全" class="headerlink" title="4.多线程如何保证安全"></a>4.多线程如何保证安全</h2><p>答：Synchronized 和 lock 上锁，Synchronized 通过反编译可以看到是通过一个 monitorenter 开始，到 monitorexit 期间操作是同步的，而 lock 相比 Synchronized 更加面向对象。</p><h2 id="5-讲一讲-Synchronized-和-lock-不同情况的锁对象"><a href="#5-讲一讲-Synchronized-和-lock-不同情况的锁对象" class="headerlink" title="5.讲一讲 Synchronized 和 lock 不同情况的锁对象"></a>5.讲一讲 Synchronized 和 lock 不同情况的锁对象</h2><p>答：Synchronized 标注在普通方法上时，锁对象是 this，而标注在静态方法上时，锁对象的 xxx.class，标注同步代码块时，默认的锁对象是自定义的。而 lock 锁分为可重入锁和读写锁，可重入锁在不同的线程中可以通过 condition 的 await()方法和 signal()方法实现线程通信的多路通知，读写锁的特点是在多线程的环境下，读读共享，读写互斥，写写也是互斥的。lock 锁的对象是谁调用 lock 谁就是锁对象</p><h2 id="6-Hash1-7-是基于数组和链表实现的，为什么不用双链表？HashMap1-8-中引入红黑树的原因是？为什么要用红黑树而不是平衡二叉树？"><a href="#6-Hash1-7-是基于数组和链表实现的，为什么不用双链表？HashMap1-8-中引入红黑树的原因是？为什么要用红黑树而不是平衡二叉树？" class="headerlink" title="6.Hash1.7 是基于数组和链表实现的，为什么不用双链表？HashMap1.8 中引入红黑树的原因是？为什么要用红黑树而不是平衡二叉树？"></a>6.Hash1.7 是基于数组和链表实现的，为什么不用双链表？HashMap1.8 中引入红黑树的原因是？为什么要用红黑树而不是平衡二叉树？</h2><p>答：使用链表的原因是为了解决 hash 冲突的问题，单链表就可以完成，使用双链表的话消耗性能更大，引入红黑树的原因是在 jdk1.7 中，hashmap 中的链表数据过大时，由于链表的数据结构的特点，查询消耗的性能过大，则采用红黑树去满足查询的功能。红黑树是自平衡数，相较于平衡二叉树在修改和删除时由于保持平衡而发生的旋转损耗性能更低，所以采用红黑树。</p><h2 id="7-HashMap、HashTable、ConcurrentHashMap-的原理与区别？"><a href="#7-HashMap、HashTable、ConcurrentHashMap-的原理与区别？" class="headerlink" title="7.HashMap、HashTable、ConcurrentHashMap 的原理与区别？"></a>7.HashMap、HashTable、ConcurrentHashMap 的原理与区别？</h2><p>答：hashtable：由数组+链表组成，无论是 key 还是 value 都不能为 null，线程安全的原因是进行修改时通过 Synchronized 锁住整个 Hashtable，导致性能低下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hashmap：插入链表之后才产生扩容，有可能产生无效扩容，线程不安全，key和value可以为null，扩容时会将map中的每个值都transfer到新的链表中。</span><br><span class="line"></span><br><span class="line">concurrentHashmap：底层采用分段的segment数组 + 链表实现，线程安全的原因是采用了锁分离技术，也就是多线程的情况下只锁住一段bucket，其他的桶可以正常进行操作修改。</span><br></pre></td></tr></table></figure><h2 id="8-volatile-与-synchronized-的区别是什么？volatile-作用（必考）"><a href="#8-volatile-与-synchronized-的区别是什么？volatile-作用（必考）" class="headerlink" title="8.volatile 与 synchronized 的区别是什么？volatile 作用（必考）"></a>8.volatile 与 synchronized 的区别是什么？volatile 作用（必考）</h2><p>答：在多线程的环境下，有三个特性，分别是原子性，可见性，有序性。volatile 可以保证在工作内存中修改的值第一时间被其他工作内存感知到，且可以保证在变量进行创建和赋值的时候保证操作的有序性，防止先给内存地址后创建对象。区别则是 volatile 只能作用在变量上，而 synchronized 可以作用在变量，方法，类上。synchronized 可能造成线程阻塞，volatile 不能保证原子性</p><h2 id="9-Atomic-类如何保证原子性（CAS-操作）（必考）"><a href="#9-Atomic-类如何保证原子性（CAS-操作）（必考）" class="headerlink" title="9.Atomic 类如何保证原子性（CAS 操作）（必考）"></a>9.Atomic 类如何保证原子性（CAS 操作）（必考）</h2><p>答：使用 volatile 关键字来保证内存的可见性，线程的读操作去主内存中读，线程在工作内存的写操作完成后立刻刷新到主内存中。但 Atomic 的原子性需要通过 CAS 自旋来保证，也就是当线程进行写操作时，保存一份旧版本数据，多线程的环境下先比较当前数据和旧版本数据是否匹配，若匹配则进行写操作。</p><h2 id="10-Java-不可重入锁与可重入锁的区别如何理解？"><a href="#10-Java-不可重入锁与可重入锁的区别如何理解？" class="headerlink" title="10.Java 不可重入锁与可重入锁的区别如何理解？"></a>10.Java 不可重入锁与可重入锁的区别如何理解？</h2><p>答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可重入锁表示一个类中的两个方法，两个方法拿到同一把锁。多线程的条件下可以是相同的线程拿到锁，也可以是不同的线程拿到锁。线程通信就是通过可重入锁的通知队列的await()方法和singal()来实现的。看源码可以知道可重入锁不仅记录了锁的数量，也记录了是谁拿到了锁，其中会判断该对象是否被锁了，是不是被此线程加锁，若是则必须等待，若不是则锁的数量加一。这样设计的好处是当锁的数量为0的时候，判断可以解锁，提供一个解锁的标准。</span><br><span class="line"></span><br><span class="line">而不可重入锁则是类似读写锁，读的操作和写的操作不可以同时进行，所以不可重入锁是不能同时被两个线程拿到，会出现死锁的问题。</span><br></pre></td></tr></table></figure><h2 id="11-多线程中-sleep-与-wait-的区别是什么？"><a href="#11-多线程中-sleep-与-wait-的区别是什么？" class="headerlink" title="11.多线程中 sleep 与 wait 的区别是什么？"></a>11.多线程中 sleep 与 wait 的区别是什么？</h2><p>答：sleep 和 wait 都是让线程进入休眠状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">不同点：1.sleep需要传参，且进入休眠之后不会释放锁资源。而wait进入休眠之后会释放锁资源</span><br><span class="line"></span><br><span class="line">  2.wait其实是使用了synchronized关键字，而sleep不用</span><br><span class="line"></span><br><span class="line">  3.wait属于Object的方法，而sleep是Thread的方法</span><br></pre></td></tr></table></figure><h2 id="12-线程的状态有哪些"><a href="#12-线程的状态有哪些" class="headerlink" title="12.线程的状态有哪些"></a>12.线程的状态有哪些</h2><p>![image-20220623171610155](&#x2F;Users&#x2F;guazi&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220623171610155.png)</p><h2 id="13-final、finnally、finalize-的区别是什么？"><a href="#13-final、finnally、finalize-的区别是什么？" class="headerlink" title="13.final、finnally、finalize 的区别是什么？"></a>13.final、finnally、finalize 的区别是什么？</h2><p>答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final是关键字，被final修饰的变量无法被修改，修饰的类无法被继承，修饰的方法无法被重写。且在类加载器的编译阶段就分配了内存空间。</span><br><span class="line"></span><br><span class="line">finally是在java进行异常处理时最后阶段一定会执行的操作</span><br><span class="line"></span><br><span class="line">finalize则是Object类的一个方法，在GC进行垃圾回收之前需要调用的方法</span><br></pre></td></tr></table></figure><h2 id="14-谈一谈你对-HashMap-的理解"><a href="#14-谈一谈你对-HashMap-的理解" class="headerlink" title="14.谈一谈你对 HashMap 的理解"></a>14.谈一谈你对 HashMap 的理解</h2><p>Hashmap 是对 map 接口的一个具体实现，它的底层数据结构在 1.7 及之前是使用数组+链表，并且在多线程的环境下有一个死锁的问题，由于链表扩容的时候采用的是头插法，所以当地一个线程创建新数组使用 transfer 方法进行数据转移完成后，第二个线程进入开始扩容时，链表的第一个节点的 next 指向下一个节点，而下一个节点的 next 指向第一个节点，这样就形成了死锁。也有人提过 issue，但是公司说这不是一个 bug，多线程的环境下 hashmap 就是不安全的，建议使用 hashtable 和 concurrenthashmap，但到了 jdk1.8 的时候，由于红黑树的出现，hashmap 的结构改成了数组+链表+红黑树，这样极端情况的时间复杂度也能保证在 O(log2n),它的扩容条件是需要链表长度大于 8 或者数组长度大于 64 会转化为红黑树。链表+红黑树主要是为了防止 hash 碰撞产生超长的链表，避免查询时需要遍历这个超长的链表导致性能下降。</p><h2 id="15-HashMap-的-put-的流程"><a href="#15-HashMap-的-put-的流程" class="headerlink" title="15. HashMap 的 put 的流程"></a>15. HashMap 的 put 的流程</h2><p>首先判断 hash 表是否为空，需不需要初始化。再判断有没有 hash 冲突，不冲突就直接插入值，如果产生 hash 冲突就要判断插入元素是否相等，如果相等则替换，如果不相等判断结构，如果结构是红黑树直接插入，如果是链表则遍历链表看是否有相同的元素，并采用尾插法，插完需要判断是否需要把链表转换为红黑树。</p><h2 id="16-了解-ConcurrentHashMap-吗-为什么性能比-hashtable-高，说下原理"><a href="#16-了解-ConcurrentHashMap-吗-为什么性能比-hashtable-高，说下原理" class="headerlink" title="16.了解 ConcurrentHashMap 吗?为什么性能比 hashtable 高，说下原理"></a>16.了解 ConcurrentHashMap 吗?为什么性能比 hashtable 高，说下原理</h2><p>由于锁的粒度越小，则并发吞吐量更高，而 ConcurrentHashMap 在高并发的环境下使用 segment 继承了重入锁将数据分成一段段存储，每个数据段配置一把锁。而 JDK1.8 之后使用了 node 数组+链表+红黑树的结构，实现了对每一段数据行加锁，减少了并发冲突的概率，而比 hashtable 效率高的原因是因为 hashtable 采用 synchronized 锁，高并发情况下效率非常的低</p><h2 id="18-ArrayList-和-LinkedList-的区别"><a href="#18-ArrayList-和-LinkedList-的区别" class="headerlink" title="18.ArrayList 和 LinkedList 的区别"></a>18.ArrayList 和 LinkedList 的区别</h2><p>答：首先 arraylist 是基于动态数组的数据结构，而 LinkedList 是基于双向链表的数据结构。数据结构的不同导致在不同的操作中有不同的优势。对于随机访问 get 和 set，arraylist 性能优于 linkedlist，因为 arraylist 是有索引的，并且 linkedlist 在操作过程中是需要移动指针的，而对于批量的随机插入删除数据，linkedlist 是优于 arraylist 的，因为 arraylist 每插入一条数据都需要移动插入点之后的所有数据</p><h2 id="19-StringBuffer-和-StringBuilder-的区别"><a href="#19-StringBuffer-和-StringBuilder-的区别" class="headerlink" title="19.StringBuffer 和 StringBuilder 的区别"></a>19.StringBuffer 和 StringBuilder 的区别</h2><p>答 stringbuffer 和 stringbuilder 的方法和功能完全相同，但是 stringbuffer 的方法中采用了同步锁 sychronized 关键字修饰，所以是线程安全的，但是 stringbuilder 没有此修饰，线程不安全。涉及到效率方面，stringbuffer 由于需要 synchornized 需要让阻塞的线程进入阻塞队列，抢到资源后进入 runable 状态。过程设计到系统用户和设计模式的转换，更加消耗资源</p><h2 id="20-线程的创建方式"><a href="#20-线程的创建方式" class="headerlink" title="20. 线程的创建方式"></a>20. 线程的创建方式</h2><p>答：线程的创建方式有四种，第一种是：继承 thread 类创建对象，缺点是 java 不能多继承。第二种实现 runable 来创建对象，看源码可知知道，在 thread 中传入一个 Runable 类型的 target，当用 run 方法前，会判断 target 是否为 null，由此来实现第二种创建线程的方法，第三种是使用 callable 和 futur</p><h2 id="21-基本类型和包装类型的区别"><a href="#21-基本类型和包装类型的区别" class="headerlink" title="21.基本类型和包装类型的区别"></a>21.基本类型和包装类型的区别</h2><ul><li>成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li><li>包装类型可用于泛型，而基本类型不可以。</li><li>基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li><li>相比于对象类型， 基本数据类型占用的空间非常小。</li></ul><p><strong>为什么说是几乎所有对象实例呢？</strong> 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p><p>⚠️ 注意 ： <strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的成员变量如果没有被 <code>static</code> 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。</p><h2 id="22-包装类型的缓存机制"><a href="#22-包装类型的缓存机制" class="headerlink" title="22.包装类型的缓存机制"></a>22.包装类型的缓存机制</h2><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p><h2 id="23-自动装箱和拆箱的原理了解嘛？"><a href="#23-自动装箱和拆箱的原理了解嘛？" class="headerlink" title="23.自动装箱和拆箱的原理了解嘛？"></a>23.自动装箱和拆箱的原理了解嘛？</h2><p>自动装箱：基本数据类型用引用数据类型包装起来；</p><p>自动拆箱：将包装类型转换为基本数据类型；</p><h2 id="24-接口和抽象类的区别"><a href="#24-接口和抽象类的区别" class="headerlink" title="24.接口和抽象类的区别"></a>24.接口和抽象类的区别</h2><p>相同点：都不可以被实例化、都可以包含抽象方法、都可以有默认的实现。</p><p>不同点：接口主要是对实现类的行为进行约束，而抽象类则更加强调从属关系、单继承，多实现、接口的成员变量被<code>public static final</code>修饰，所以不能修改且必须有初始值，而抽象类的成员变量可以在子类中重新定义和赋值。</p><h2 id="25-浅拷贝，深拷贝，引用拷贝了解吗？"><a href="#25-浅拷贝，深拷贝，引用拷贝了解吗？" class="headerlink" title="25.浅拷贝，深拷贝，引用拷贝了解吗？"></a>25.浅拷贝，深拷贝，引用拷贝了解吗？</h2><p>引用拷贝是不同引用指向同一对象，深拷贝则是不同引用指向不同对象，浅拷贝则是不同引用指向不同对象的成员属性。</p><h2 id="26-equal-和-x3D-x3D-的区别？"><a href="#26-equal-和-x3D-x3D-的区别？" class="headerlink" title="26.equal 和&#x3D;&#x3D;的区别？"></a>26.equal 和&#x3D;&#x3D;的区别？</h2><p>&#x3D;&#x3D;：基本属性类型比值。引用数据类型比地址。</p><p>equal：不重写则是引用 Object 类下的 equal 跟<code>==</code>一样,若重写则一般比较属性值。</p><h2 id="27-为什么重写-equal-同时必须重写-hashcode-方法？"><a href="#27-为什么重写-equal-同时必须重写-hashcode-方法？" class="headerlink" title="27.为什么重写 equal()同时必须重写 hashcode()方法？"></a>27.为什么重写 equal()同时必须重写 hashcode()方法？</h2><p>因为无论是 equal()还是 hashcode()方法，最终目的都是比较两个对象是否相同。而 equal 只能保证对象相等，hash 值不相等。而只有 hashcode()的话可能会产生 hash 碰撞的问题。</p><h2 id="28-String、StringBuffer、StringBuilder-的区别？"><a href="#28-String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="28.String、StringBuffer、StringBuilder 的区别？"></a>28.String、StringBuffer、StringBuilder 的区别？</h2><p>可变性：String 是不可变的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   StringBuffer和StringBuilder都是继承自AbstractStringBuilder类，类中包含了许多操作字符串的方法。</span><br></pre></td></tr></table></figure><p>线程安全性：</p><ul><li>String 是线程安全的</li><li>StringBuffer 加了同步锁，是线程安全的。</li><li>StringBuilder 没有加同步锁，线程不安全。</li></ul><p>性能：</p><ul><li>String 每次操作都会创建新的对象</li><li>StringBuilder 比 StringBuffer 性能高 10%-15%，但是需要冒着线程不安全的风险。</li></ul><h2 id="29-和-StringBuilder-用于字符串拼接的区别？"><a href="#29-和-StringBuilder-用于字符串拼接的区别？" class="headerlink" title="29.+和 StringBuilder 用于字符串拼接的区别？"></a>29.+和 StringBuilder 用于字符串拼接的区别？</h2><p><code>+</code>：其实也是调用 StringBuilder 的 append()方法进行拼接，但是他不会复用 StringBuilder 对象。所以一般考虑 StringBuidler 来字符串拼接。并且拼接之前会进行常量折叠：对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code> 编译器会给你优化成 <code>String str3 = &quot;string&quot;;</code> 。</p><h2 id="30-String-s1-x3D-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#30-String-s1-x3D-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="30.String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？"></a>30.String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</h2><p>一个或两个，如果常量池没有“abc”则需要创建，若有则不需要创建。之后会把 String 对象引用指向常量池的”abc”.</p><h2 id="31-什么是泛型，泛型有几种使用方式？"><a href="#31-什么是泛型，泛型有几种使用方式？" class="headerlink" title="31.什么是泛型，泛型有几种使用方式？"></a>31.什么是泛型，泛型有几种使用方式？</h2><p>泛型就是编译器可以对泛型类型进行检查，可以指定传入的对象类型。比如 <code>ArrayList&lt;Persion&gt; persons = new ArrayList&lt;Persion&gt;()</code> 这行代码就指明了该 <code>ArrayList</code> 对象只能传入 <code>Persion</code> 对象，如果传入其他类型的对象就会报错。</p><p>三种使用方式：</p><ul><li>泛型类指定成员属性类型</li><li>泛型接口指定抽象方法的返回参数</li><li>泛型方法</li></ul><h2 id="32-什么是序列化-什么是反序列化？"><a href="#32-什么是序列化-什么是反序列化？" class="headerlink" title="32.什么是序列化?什么是反序列化？"></a>32.什么是序列化?什么是反序列化？</h2><p>当 java 对象需要持久化或者通过网络传输时，都需要先序列化成二进制的字节流。</p><h2 id="33-ArrayList-与-LinkedList-区别"><a href="#33-ArrayList-与-LinkedList-区别" class="headerlink" title="33.ArrayList 与 LinkedList 区别?"></a>33.ArrayList 与 LinkedList 区别?</h2><ul><li>都是线程不安全的</li><li>Arraylist 是 Object[]数组而 LinkedList 是使用的双向链表</li><li>ArrayList 数组存储，add 直接在末尾插入，时间复杂度是 O(1),指定位置插入和删除的话时间复杂度是 O(n-1)，因为之后的元素都需要移动位置。LinkedList 是链表存储，所以头尾插入时间复杂度是 O(1),如果指定位置插入或者删除的话时间复杂度是 O(n)。</li><li>ArrayList 支持快速访问元素，而 LinkedList 不支持。</li><li>总结，直接用 ArrayList 就完事儿了。</li></ul><h2 id="34-Arraylist-的扩容机制你了解多少？"><a href="#34-Arraylist-的扩容机制你了解多少？" class="headerlink" title="34.Arraylist 的扩容机制你了解多少？"></a>34.Arraylist 的扩容机制你了解多少？</h2><p>arraylist 继承与**<code>AbstractList</code>**,实现了 list，RandomAccess，Cloneable，Serializable 等接口，支持随机访问、克隆、序列化等。</p><p>调用无参构造初始化后默认容量为 10.grow(默认容量)方法中通过位右移并+默认容量来扩容，1.5 倍。判断扩容后的容量是否大于最小容量，若不大于则设最小容量为 arraylist 容量。如果超过 integer.max_value 则设置为 integer 最大值-8。System.arraycopy()复制数组指定位置指定长度的数据到新数组的指定位置。Arrays.copyof()主要是给数组扩容。其中的 ensureCapacity()在进行大量 add 操作时使用，可以减少增量重新分配的次数。他会增加 arraylist 实例的容量，防止多次进行 grow().</p><h2 id="35-MyISAM-和-InnoDB-的区别是什么？"><a href="#35-MyISAM-和-InnoDB-的区别是什么？" class="headerlink" title="35.MyISAM 和 InnoDB 的区别是什么？"></a>35.MyISAM 和 InnoDB 的区别是什么？</h2><ul><li>MyISAM 不支持行锁，而 InnoDB 支持行锁且支持表锁。</li><li>MyISAM 没有事务，但是 InnoDB 支持事务。</li><li>MyISAM 不支持外键，但是 InnoDB 支持外键。</li><li>MyISAM 不支持安全恢复，InnoDB 支持</li><li>索引实现不一样，虽然都是使用 B+Tree，MyISAM 中索引和数据是分离的，数据文件本身按照 B+Tree 组织的索引结构，叶节点的 data 中存储了所有的数据。</li></ul><h2 id="36-聚簇索引和非聚簇索引的优缺点？"><a href="#36-聚簇索引和非聚簇索引的优缺点？" class="headerlink" title="36.聚簇索引和非聚簇索引的优缺点？"></a>36.聚簇索引和非聚簇索引的优缺点？</h2><p>聚簇索引是 data 中同时存放数据和索引结构，非聚簇索引分开存放结构和索引。</p><p>聚簇索引查询速度非常快，但是依赖数据有序和数据的类型。并且更新代价很大。</p><p>非聚簇索引更新的代价很小，但是同样依赖有序的数据，也可能会二次查询(回表)</p><h2 id="37-Spring-中-FactoryBean-和-BeanFactory-的区别？"><a href="#37-Spring-中-FactoryBean-和-BeanFactory-的区别？" class="headerlink" title="37.Spring 中 FactoryBean 和 BeanFactory 的区别？"></a>37.Spring 中 FactoryBean 和 BeanFactory 的区别？</h2><p>也就是工厂 Bean 和 Bean 工厂的区别，Bean 工厂，顾名思义是根据类的属性去生成我们需要的各种各样的 Bean，也就是说 Bean 工厂其实是提供了一套规范来获取 Bean 实例，那么工厂 Bean 则是动态的生成某一类型的 Bean 实例，可以自定义一个 Bean 加载到 IOC 容器中。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
